from typing import Literal, Annotated
from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain_openai import AzureChatOpenAI
from langgraph.graph import StateGraph, START, END
from langgraph.prebuilt import ToolNode, ToolExecutor
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from elasticsearch import Elasticsearch
from dotenv import load_dotenv
import json
import os
import urllib.parse
from sqlalchemy import create_engine
from langchain.sql_database import SQLDatabase
from langchain.agents.agent_toolkits import SQLDatabaseToolkit
from langchain.agents import create_sql_agent
from langchain_core.tools import Tool
from langchain_core.pydantic_v1 import BaseModel, Field

# Load environment variables
load_dotenv()

class Config:
    def __init__(self):
        # Elasticsearch config
        self.elastic_index_data_from = 0
        self.elastic_index_data_size = 10
        self.elastic_index_data_max_size = 50
        self.aggs_limit = 5
        self.max_search_retries = 3
        self.token_limit = 3000
        
        # Initialize Elasticsearch client
        self.es = Elasticsearch(
            os.getenv("ELASTIC_ENDPOINT"),
            api_key=os.getenv("ELASTIC_API_KEY"),
            verify_certs=False
        )
        
        # Initialize LLM
        self.llm = AzureChatOpenAI(
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
            deployment_name="gpt-4",
            model="gpt-4",
            temperature=0
        )
        
        # SQL Server connection setup
        driver = '{ODBC Driver 18 for SQL Server}'
        server = os.getenv("SQL_SERVER")
        database = os.getenv("SQL_DATABASE")
        user = os.getenv("SQL_USER")
        password = os.getenv("SQL_PASSWORD")
        
        conn = f"Driver={driver};Server=tcp:{server},1433;Database={database};Uid={user};Pwd={password};Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;"
        params = urllib.parse.quote_plus(conn)
        conn_str = f'mssql+pyodbc:///?autocommit=true&odbc_connect={params}'
        engine = create_engine(conn_str, echo=True)
        self.sql_db = SQLDatabase(engine, schema="comp")
        
        self.langchain_verbose = True

cfg = Config()

# ================== Elasticsearch Tools ==================
class ListIndicesInput(BaseModel):
    separator: str = Field(", ", description="Separator for the list of indices")

class IndexDetailsInput(BaseModel):
    index_name: str = Field(..., description="Name of the Elasticsearch index")

class IndexDataInput(BaseModel):
    index_name: str = Field(..., description="Name of the Elasticsearch index")
    size: int = Field(5, description="Number of documents to retrieve")

class SearchToolInput(BaseModel):
    index_name: str = Field(..., description="Name of the Elasticsearch index")
    query: str = Field(..., description="Elasticsearch JSON query")
    from_: int = Field(0, description="Starting record index")
    size: int = Field(10, description="Number of records to retrieve")

def list_indices(separator: str = ", ") -> str:
    """Lists all available Elasticsearch indices"""
    try:
        indices = list(cfg.es.indices.get(index="*").keys())
        return f"Available indices:{separator}{separator.join(indices)}"
    except Exception as e:
        return f"Error listing indices: {str(e)}"

def get_index_details(index_name: str) -> str:
    """Gets details about a specific index including mappings and settings"""
    try:
        if not cfg.es.indices.exists(index=index_name):
            return f"Index '{index_name}' does not exist"
        details = {
            "aliases": cfg.es.indices.get_alias(index=index_name).get(index_name, {}).get("aliases", {}),
            "mappings": cfg.es.indices.get_mapping(index=index_name).get(index_name, {}).get("mappings", {}),
            "settings": cfg.es.indices.get_settings(index=index_name).get(index_name, {}).get("settings", {})
        }
        return json.dumps(details, indent=2)
    except Exception as e:
        return f"Error getting index details: {str(e)}"

def get_index_data(index_name: str, size: int = 5) -> str:
    """Gets sample documents from an index to understand its structure"""
    try:
        if not cfg.es.indices.exists(index=index_name):
            return f"Index '{index_name}' does not exist"
        result = cfg.es.search(
            index=index_name,
            body={"query": {"match_all": {}}},
            size=min(size, cfg.elastic_index_data_max_size)
        )
        hits = result.get('hits', {}).get('hits', [])
        if not hits:
            return f"No documents found in index '{index_name}'"
        return json.dumps([hit['_source'] for hit in hits[:size]], indent=2)
    except Exception as e:
        return f"Error getting index data: {str(e)}"

def elastic_search(index_name: str, query: str, from_: int = 0, size: int = 10) -> str:
    """Executes a search or aggregation query on an Elasticsearch index"""
    try:
        if not cfg.es.indices.exists(index=index_name):
            return f"Index '{index_name}' does not exist"
        size = min(cfg.elastic_index_data_max_size, size)
        try:
            query_dict = json.loads(query)
        except json.JSONDecodeError:
            return "Invalid query format - must be valid JSON"

        is_aggregation = "aggs" in query_dict or "aggregations" in query_dict
        if is_aggregation:
            size = cfg.aggs_limit

        result = cfg.es.search(
            index=index_name,
            body=query_dict,
            from_=from_,
            size=size
        )

        if is_aggregation:
            return json.dumps(result.get('aggregations', {}), indent=2)
        else:
            return json.dumps(result.get('hits', {}), indent=2)
    except Exception as e:
        return f"Search error: {str(e)}"

elastic_tools = [
    Tool.from_function(
        func=list_indices,
        name="elastic_list_indices",
        description="Lists all available Elasticsearch indices. Always call this first.",
        args_schema=ListIndicesInput
    ),
    Tool.from_function(
        func=get_index_details,
        name="elastic_index_details",
        description="Gets details about a specific index including mappings and settings",
        args_schema=IndexDetailsInput
    ),
    Tool.from_function(
        func=get_index_data,
        name="elastic_index_data",
        description="Gets sample documents from an index to understand its structure",
        args_schema=IndexDataInput
    ),
    Tool.from_function(
        func=elastic_search,
        name="elastic_search",
        description="Executes search or aggregation queries on an Elasticsearch index",
        args_schema=SearchToolInput
    )
]

# ================== Elasticsearch Agent ==================
def create_elastic_agent() -> AgentExecutor:
    prompt = ChatPromptTemplate.from_messages([
        SystemMessage(content="You are an Elasticsearch expert assistant"),
        ("user", "{input}"),
        MessagesPlaceholder(variable_name="agent_scratchpad")
    ])
    
    agent = create_openai_tools_agent(
        llm=cfg.llm,
        tools=elastic_tools,
        prompt=prompt
    )
    
    return AgentExecutor(
        agent=agent,
        tools=elastic_tools,
        verbose=cfg.langchain_verbose,
        handle_parsing_errors=True
    )

elastic_agent_executor = create_elastic_agent()

# ================== SQL Agent ==================
sql_toolkit = SQLDatabaseToolkit(db=cfg.sql_db, llm=cfg.llm)
sql_agent_executor = create_sql_agent(
    llm=cfg.llm,
    toolkit=sql_toolkit,
    verbose=cfg.langchain_verbose,
    handle_parsing_errors=True
)

# ================== Multi-Agent Supervisor ==================
def supervisor(state: dict) -> Literal["elastic_agent", "sql_agent", END]:
    """Routes to appropriate agent based on user input"""
    try:
        messages = state.get("messages", [])
        if not messages:
            return END
        
        user_input = messages[-1].content
        
        # Simple routing logic - in production you'd use the LLM for this
        if any(keyword in user_input.lower() for keyword in ["elastic", "index", "search"]):
            return "elastic_agent"
        elif any(keyword in user_input.lower() for keyword in ["sql", "database", "query"]):
            return "sql_agent"
        else:
            return END
    except Exception as e:
        print(f"Supervisor error: {str(e)}")
        return END

# ================== Agent Nodes ==================
def elastic_agent(state: dict):
    """Elasticsearch agent node"""
    try:
        messages = state.get("messages", [])
        if not messages:
            return {"messages": []}
        
        user_input = messages[-1].content
        result = elastic_agent_executor.invoke({"input": user_input})
        return {"messages": [AIMessage(content=result["output"])]}
    except Exception as e:
        return {"messages": [AIMessage(content=f"Elasticsearch error: {str(e)}")]}

def sql_agent(state: dict):
    """SQL agent node"""
    try:
        messages = state.get("messages", [])
        if not messages:
            return {"messages": []}
        
        user_input = messages[-1].content
        result = sql_agent_executor.run(user_input)
        return {"messages": [AIMessage(content=str(result))]}
    except Exception as e:
        return {"messages": [AIMessage(content=f"SQL error: {str(e)}")]}

# ================== Build Graph ==================
builder = StateGraph(dict)

# Add nodes
builder.add_node("supervisor", supervisor)
builder.add_node("elastic_agent", elastic_agent)
builder.add_node("sql_agent", sql_agent)

# Set edges
builder.add_edge(START, "supervisor")
builder.add_edge("elastic_agent", "supervisor")
builder.add_edge("sql_agent", "supervisor")

# Set termination point
builder.add_edge("supervisor", END)

# Conditional edges
builder.add_conditional_edges(
    "supervisor",
    lambda state: state["supervisor"],
    {
        "elastic_agent": "elastic_agent",
        "sql_agent": "sql_agent",
        END: END
    }
)

multi_agent = builder.compile()

# ================== Example Usage ==================
if __name__ == "__main__":
    test_queries = [
        "List all Elasticsearch indices",
        "How many customers do we have in the database?",
        "Show me sample documents from the logs index",
        "What are the top 5 products by sales?"
    ]
    
    for query in test_queries:
        print(f"\nUser: {query}")
        result = multi_agent.invoke({"messages": [HumanMessage(content=query)]})
        print(f"Assistant: {result['messages'][-1].content}")
