from typing import Dict, List, Union
from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain_openai import AzureChatOpenAI
from langgraph.graph import StateGraph, START, END
from langchain.schema import HumanMessage, AIMessage, SystemMessage
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from elasticsearch import Elasticsearch
from dotenv import load_dotenv
import json
import os
import urllib.parse
from sqlalchemy import create_engine
from langchain.sql_database import SQLDatabase
from langchain.agents.agent_toolkits import SQLDatabaseToolkit
from langchain.agents import create_sql_agent
from langchain.tools import Tool
from langchain.pydantic_v1 import BaseModel, Field

# Load environment variables
load_dotenv()

class Config:
    def __init__(self):
        # Elasticsearch config
        self.elastic_index_data_from = 0
        self.elastic_index_data_size = 10
        self.elastic_index_data_max_size = 50
        self.aggs_limit = 5
        self.max_search_retries = 3
        self.token_limit = 3000
        
        # Initialize Elasticsearch client
        self.es = Elasticsearch(
            os.getenv("ELASTIC_ENDPOINT", "http://localhost:9200"),
            api_key=os.getenv("ELASTIC_API_KEY"),
            verify_certs=False
        )
        
        # Initialize LLM
        self.llm = AzureChatOpenAI(
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
            deployment_name="gpt-4",
            model="gpt-4",
            temperature=0
        )
        
        # SQL Server connection setup
        driver = '{ODBC Driver 18 for SQL Server}'
        server = os.getenv("SQL_SERVER", "localhost")
        database = os.getenv("SQL_DATABASE", "master")
        user = os.getenv("SQL_USER", "sa")
        password = os.getenv("SQL_PASSWORD", "password")
        
        conn = f"Driver={driver};Server=tcp:{server},1433;Database={database};Uid={user};Pwd={password};Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;"
        params = urllib.parse.quote_plus(conn)
        conn_str = f'mssql+pyodbc:///?autocommit=true&odbc_connect={params}'
        engine = create_engine(conn_str)
        self.sql_db = SQLDatabase(engine, schema="dbo")
        
        self.langchain_verbose = True

cfg = Config()

# ================== Elasticsearch Tools ==================

class ListIndicesInput(BaseModel):
    pattern: str = Field(default="*", description="Index pattern to match")

def list_indices(pattern: str = "*") -> str:
    """List all Elasticsearch indices matching a pattern"""
    try:
        response = cfg.es.cat.indices(index=pattern, format="json")
        return json.dumps(response, indent=2)
    except Exception as e:
        return f"Error listing indices: {str(e)}"

class SearchIndexInput(BaseModel):
    index_name: str = Field(description="Name of the index to search")
    query: str = Field(description="Elasticsearch query in JSON format")
    size: int = Field(default=10, description="Number of results to return")

def search_index(index_name: str, query: str, size: int = 10) -> str:
    """Search documents in an Elasticsearch index"""
    try:
        query_json = json.loads(query)
        response = cfg.es.search(index=index_name, body=query_json, size=size)
        return json.dumps(response, indent=2)
    except Exception as e:
        return f"Error searching index: {str(e)}"

class GetIndexMappingInput(BaseModel):
    index_name: str = Field(description="Name of the index")

def get_index_mapping(index_name: str) -> str:
    """Get mapping for an Elasticsearch index"""
    try:
        response = cfg.es.indices.get_mapping(index=index_name)
        return json.dumps(response, indent=2)
    except Exception as e:
        return f"Error getting index mapping: {str(e)}"

# Create Elasticsearch tools
elastic_tools = [
    Tool(
        name="list_indices",
        func=list_indices,
        description="List all Elasticsearch indices matching a pattern",
        args_schema=ListIndicesInput
    ),
    Tool(
        name="search_index",
        func=search_index,
        description="Search documents in an Elasticsearch index. Input should be index name and a JSON query.",
        args_schema=SearchIndexInput
    ),
    Tool(
        name="get_index_mapping",
        func=get_index_mapping,
        description="Get mapping/schema for an Elasticsearch index",
        args_schema=GetIndexMappingInput
    )
]

# ================== Elasticsearch Agent ==================
def create_elastic_agent() -> AgentExecutor:
    prompt = ChatPromptTemplate.from_messages([
        SystemMessage(content="You are an Elasticsearch expert assistant"),
        ("user", "{input}"),
        MessagesPlaceholder(variable_name="agent_scratchpad")
    ])
    
    agent = create_openai_tools_agent(
        llm=cfg.llm,
        tools=elastic_tools,
        prompt=prompt
    )
    
    return AgentExecutor(
        agent=agent,
        tools=elastic_tools,
        verbose=cfg.langchain_verbose,
        handle_parsing_errors=True
    )

elastic_agent_executor = create_elastic_agent()

# ================== SQL Agent ==================
sql_toolkit = SQLDatabaseToolkit(db=cfg.sql_db, llm=cfg.llm)
sql_agent_executor = create_sql_agent(
    llm=cfg.llm,
    toolkit=sql_toolkit,
    verbose=cfg.langchain_verbose,
    handle_parsing_errors=True
)

# ================== State Definition ==================
class AgentState(dict):
    @property
    def messages(self) -> List[Union[HumanMessage, AIMessage]]:
        return self.get("messages", [])
    
    @property
    def next_node(self) -> str:
        return self.get("next_node", "END")

# ================== Multi-Agent Supervisor ==================
def supervisor(state: AgentState) -> Dict:
    """Routes to appropriate agent based on user input"""
    try:
        current_messages = state.messages.copy() if state.messages else []
        
        if not current_messages:
            return {"messages": [], "next_node": "END"}
        
        user_input = current_messages[-1].content
        
        # Routing logic
        if any(keyword in user_input.lower() for keyword in ["elastic", "index", "search"]):
            return {"messages": current_messages, "next_node": "elastic_agent"}
        elif any(keyword in user_input.lower() for keyword in ["sql", "database", "query", "table"]):
            return {"messages": current_messages, "next_node": "sql_agent"}
        else:
            # Default to Elasticsearch if unsure
            return {"messages": current_messages, "next_node": "elastic_agent"}
    except Exception as e:
        error_msg = AIMessage(content=f"Supervisor error: {str(e)}")
        return {
            "messages": state.messages + [error_msg],
            "next_node": "END"
        }

# ================== Agent Nodes ==================
def elastic_agent(state: AgentState) -> Dict:
    """Elasticsearch agent node"""
    try:
        current_messages = state.messages.copy()
        if not current_messages:
            return {"messages": [], "next_node": "supervisor"}
        
        user_input = current_messages[-1].content
        result = elastic_agent_executor.invoke({"input": user_input})
        return {
            "messages": current_messages + [AIMessage(content=result["output"])],
            "next_node": "supervisor"
        }
    except Exception as e:
        return {
            "messages": state.messages + [AIMessage(content=f"Elasticsearch error: {str(e)}")],
            "next_node": "supervisor"
        }

def sql_agent(state: AgentState) -> Dict:
    """SQL agent node"""
    try:
        current_messages = state.messages.copy()
        if not current_messages:
            return {"messages": [], "next_node": "supervisor"}
        
        user_input = current_messages[-1].content
        result = sql_agent_executor.run(user_input)
        return {
            "messages": current_messages + [AIMessage(content=str(result))],
            "next_node": "supervisor"
        }
    except Exception as e:
        return {
            "messages": state.messages + [AIMessage(content=f"SQL error: {str(e)}")],
            "next_node": "supervisor"
        }

# ================== Build Graph ==================
builder = StateGraph(AgentState)

# Add nodes
builder.add_node("supervisor", supervisor)
builder.add_node("elastic_agent", elastic_agent)
builder.add_node("sql_agent", sql_agent)

# Set edges
builder.add_edge(START, "supervisor")
builder.add_edge("elastic_agent", "supervisor")
builder.add_edge("sql_agent", "supervisor")

# Set termination point
builder.add_edge("supervisor", END)

# Conditional edges
builder.add_conditional_edges(
    "supervisor",
    lambda state: state.next_node,
    {
        "elastic_agent": "elastic_agent",
        "sql_agent": "sql_agent",
        "END": END
    }
)

# Set the entry point
builder.set_entry_point("supervisor")

multi_agent = builder.compile()

# ================== Example Usage ==================
def run_query(query: str):
    """Helper function to run a query through the multi-agent system"""
    print(f"\nUser: {query}")
    initial_state = AgentState({
        "messages": [HumanMessage(content=query)],
        "next_node": None
    })
    
    result = multi_agent.invoke(initial_state)
    
    if result.get("messages") and len(result["messages"]) > 0:
        last_message = result["messages"][-1]
        if hasattr(last_message, 'content'):
            print(f"Assistant: {last_message.content}")
        else:
            print("Assistant: (No content in message)")
    else:
        print("Assistant: No response generated")

if __name__ == "__main__":
    # Test with sample queries
    test_queries = [
        "List all Elasticsearch indices",
        "Show me the mapping for the 'logs' index",
        "Search for documents in 'products' index where price is greater than 100",
        "How many tables are in the database?",
        "What are the columns in the 'customers' table?",
        "Find products with names containing 'laptop'"
    ]
    
    for query in test_queries:
        run_query(query)
