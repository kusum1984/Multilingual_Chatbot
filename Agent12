from typing import Annotated, Literal
from langchain_openai import ChatOpenAI
from langgraph.prebuilt import InjectedState, create_react_agent
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.types import Command
from langchain_core.messages import HumanMessage, AIMessage
from elasticsearch import Elasticsearch
from dotenv import load_dotenv
import json
import os
import urllib.parse
from sqlalchemy import create_engine
from langchain.sql_database import SQLDatabase
from langchain.agents.agent_toolkits import SQLDatabaseToolkit
from langchain.agents import create_sql_agent

# Load environment variables
load_dotenv()

class Config:
    def __init__(self):
        # Elasticsearch config
        self.elastic_index_data_from = 0
        self.elastic_index_data_size = 10
        self.elastic_index_data_max_size = 50
        self.aggs_limit = 5
        self.max_search_retries = 3
        self.token_limit = 3000
        
        # Initialize Elasticsearch client
        self.es = Elasticsearch(
            os.getenv("ELASTIC_ENDPOINT"),
            api_key=os.getenv("ELASTIC_API_KEY"),
            verify_certs=False
        )
        
        # Initialize LLM
        self.llm = ChatOpenAI(
            api_key=os.getenv("OPENAI_API_KEY"),
            model="gpt-4",
            temperature=0
        )
        
        # SQL Server connection setup
        driver = '{ODBC Driver 18 for SQL Server}'
        server = os.getenv("SQL_SERVER")
        database = os.getenv("SQL_DATABASE")
        user = os.getenv("SQL_USER")
        password = os.getenv("SQL_PASSWORD")
        
        conn = f"Driver={driver};Server=tcp:{server},1433;Database={database};Uid={user};Pwd={password};Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;"
        params = urllib.parse.quote_plus(conn)
        conn_str = f'mssql+pyodbc:///?autocommit=true&odbc_connect={params}'
        engine = create_engine(conn_str, echo=True)
        self.sql_db = SQLDatabase(engine, schema="comp")
        
        self.langchain_verbose = True

cfg = Config()

# ================== Elasticsearch Team ==================
def elastic_agent(state: Annotated[dict, InjectedState]):
    """Handles all Elasticsearch related queries"""
    try:
        user_input = state["messages"][-1].content if state.get("messages") else ""
        
        # Simplified Elasticsearch tools implementation
        if "list indices" in user_input.lower():
            indices = list(cfg.es.indices.get(index="*").keys())
            return {"messages": [AIMessage(content=f"Available indices: {', '.join(indices)}")]}
        elif "sample documents" in user_input.lower():
            index_name = "logs"  # Simplified - would extract from input in real implementation
            result = cfg.es.search(index=index_name, body={"query": {"match_all": {}}}, size=3)
            hits = [hit['_source'] for hit in result['hits']['hits']]
            return {"messages": [AIMessage(content=json.dumps(hits, indent=2))]}
        else:
            return {"messages": [AIMessage(content="Performed Elasticsearch operation")]}
    except Exception as e:
        return {"messages": [AIMessage(content=f"Elasticsearch error: {str(e)}")]}

def elastic_supervisor(state: MessagesState) -> Command[Literal["elastic_agent", END]]:
    """Routes to Elasticsearch agent or ends conversation"""
    # In a real implementation, this would use the LLM to decide next step
    return Command(goto="elastic_agent")

# Build Elasticsearch team graph
elastic_builder = StateGraph(MessagesState)
elastic_builder.add_node("elastic_supervisor", elastic_supervisor)
elastic_builder.add_node("elastic_agent", elastic_agent)
elastic_builder.add_edge(START, "elastic_supervisor")
elastic_builder.add_edge("elastic_supervisor", "elastic_agent")
elastic_builder.add_edge("elastic_agent", END)  # Simple one-step flow for demo
elastic_team = elastic_builder.compile()

# ================== SQL Team ==================
def sql_agent(state: Annotated[dict, InjectedState]):
    """Handles all SQL database related queries"""
    try:
        user_input = state["messages"][-1].content if state.get("messages") else ""
        
        toolkit = SQLDatabaseToolkit(db=cfg.sql_db, llm=cfg.llm)
        agent = create_sql_agent(
            llm=cfg.llm,
            toolkit=toolkit,
            verbose=cfg.langchain_verbose,
            handle_parsing_errors=True
        )
        result = agent.run(user_input)
        return {"messages": [AIMessage(content=str(result))]}
    except Exception as e:
        return {"messages": [AIMessage(content=f"SQL error: {str(e)}")]}

def sql_supervisor(state: MessagesState) -> Command[Literal["sql_agent", END]]:
    """Routes to SQL agent or ends conversation"""
    return Command(goto="sql_agent")

# Build SQL team graph
sql_builder = StateGraph(MessagesState)
sql_builder.add_node("sql_supervisor", sql_supervisor)
sql_builder.add_node("sql_agent", sql_agent)
sql_builder.add_edge(START, "sql_supervisor")
sql_builder.add_edge("sql_supervisor", "sql_agent")
sql_builder.add_edge("sql_agent", END)  # Simple one-step flow for demo
sql_team = sql_builder.compile()

# ================== Top-Level Supervisor ==================
def top_level_supervisor(state: MessagesState) -> Command[Literal["elastic_team", "sql_team", END]]:
    """Routes to appropriate team based on user input"""
    user_input = state["messages"][-1].content
    
    # Simple routing logic - in real implementation would use LLM
    if any(keyword in user_input.lower() for keyword in ["elastic", "index", "search"]):
        return Command(goto="elastic_team")
    elif any(keyword in user_input.lower() for keyword in ["sql", "database", "query"]):
        return Command(goto="sql_team")
    else:
        return Command(goto=END)

# Build top-level graph
builder = StateGraph(MessagesState)
builder.add_node("top_level_supervisor", top_level_supervisor)
builder.add_node("elastic_team", elastic_team)
builder.add_node("sql_team", sql_team)
builder.add_edge(START, "top_level_supervisor")
builder.add_edge("top_level_supervisor", "elastic_team")
builder.add_edge("top_level_supervisor", "sql_team")
builder.add_edge("elastic_team", END)
builder.add_edge("sql_team", END)
hierarchical_agent = builder.compile()

# ================== Example Usage ==================
if __name__ == "__main__":
    test_queries = [
        "List all Elasticsearch indices",
        "How many customers do we have in the database?",
        "Show me sample documents from the logs index",
        "What are the top 5 products by sales?"
    ]
    
    for query in test_queries:
        print(f"\nUser: {query}")
        state = {"messages": [HumanMessage(content=query)]}
        result = hierarchical_agent.invoke(state)
        print(f"Assistant: {result['messages'][-1].content}")
